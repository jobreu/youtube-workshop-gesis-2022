---
title: 'Exercises Preprocessing and Data Cleaning - Solutions'
# title: 'Exercises Preprocessing and Data Cleaning' 
author: 'Julian Kohne, Johannes Breuer, M. Rohangis Mohseni'
date: 'Automatic sampling and analysis of YouTube data, February 21-22, 2022'
output:
  unilur::tutorial_html: default
  #unilur::tutorial_html_solution: default
---

```{r knitr_init, echo=FALSE, cache=FALSE, include=FALSE}
# custom boxes
knitr::opts_template$set(clues = list(box.title = "Clues",
                                      box.body = list(fill = "#fff9dc", colour = "black"),
                                      box.header = list(fill = "#ffec8b", colour = "black"),
                                      box.icon = "fa-search",
                                      box.collapse = TRUE))

```

```{r klippy, echo=FALSE, include=TRUE}
klippy::klippy()
```

In these exercises, we will be going through the dataset you scraped and preprocess it for further analysis. If you couldn't scrape your own dataset for some reason, you can use one provided by us: `RawComments.rds`. Should you run into any problems, try using the clue boxes or asking us for help. For the solutions, we will be using the prepared dataset. If you use a different one, be sure to replace the names and paths in the code accordingly.

```{block, box.title = "Exercise 1", box.body = list(fill = "white"), box.icon = "fa-star"}
Load your scraped dataset or the one we prepared for you into your `R` session and assign it to an object called `comments`. Get an overview of the contained variables. What do the variables describe? Why do we have missing data in some of them?
```

```{block, opts.label = "clues"}
To load the data, you can use the `readRDS()` function, to get an overview of the contained variables, you can simply use `colnames()`. To find out more about what the variables mean, you can have a look at the *YouTube* data API documentation and search for the variable descriptions.

```

```{r, results = 'hide', solution = TRUE}
# Load datas
comments <- readRDS("../data/RawComments.rds")

# overview of columns
colnames(comments)

```

```{block, solution = TRUE}

The [YouTube API documentation](https://developers.google.com/youtube/v3/docs/comments)

```


```{block, box.title = "Exercise 2", box.body = list(fill = "white"), box.icon = "fa-star"}
We want to remove the variables `authorProfileImageUrl`, `authorChannelUrl`, `authorChannelUrl.value`,`video_id`,`canRate` and `viewerRating` and `moderationStatus`. Create a new dataframe called `Selection` containing only the remaining variables.
```

```{block, opts.label = "clues"}
You can use the `subset()` function to keep or remove a selection of variables from a dataframe. For more information on how to use it, have a look at its documentation by running `?subset()`.

```

```{r, results = 'hide', solution = TRUE}
# selecting only the columns we need
Selection <- subset(comments,select = -c(authorProfileImageUrl,
                                         authorChannelUrl,
                                         authorChannelId.value,
                                         videoId,
                                         canRate,
                                         viewerRating,
                                         moderationStatus))
# Checking Selection
colnames(Selection)

```

```{block, box.title = "Exercise 3", box.body = list(fill = "white"), box.icon = "fa-star"}
Check the class of the variable `publishedAt` in your new dataframe. Is this class suitable for further analysis? If not, change the class to the appropriate one and compute the time difference in publishing dates between the comment in the first row and the comment in the last row.

Do the same transformation for the variable `updatedAt`

```

```{block, opts.label = "clues"}
To check the class of the `publishedAt` variable, you can use the `class()` function. To check the formatting of the comment timestamp, you can check the [YouTube API documentation](https://developers.google.com/youtube/v3/docs/comments). To transform character strings into datetime objects in `R`, you can use the base `R` function `as.POSIXct()` or the more convenient `anytime()` function from the package with the same name.

```

```{r, results = 'hide' ,solution = TRUE}
# checking variable class
class(Selection$publishedAt)

# transforming to datetime object with as.POISXct
DateTime <- as.POSIXct(Selection$publishedAt,format = "%Y-%m-%dT%H:%M:%SZ")

# transforming to datetime object with anytime
library(anytime)
Selection$publishedAt <- anytime(Selection$publishedAt,asUTC = TRUE)
class(Selection$publishedAt)

# computing time difference in publishing time between first and last comment
Selection$publishedAt[1] - Selection$publishedAt[dim(Selection)[1]]

# Transforming the updatedAt variable as well
Selection$updatedAt <- anytime(Selection$updatedAt,asUTC = TRUE)

```

```{block, box.title = "Exercise 4", box.body = list(fill = "white"), box.icon = "fa-star"}
Check the `likeCount` variable in your data. Is it suitable for numeric analysis? If not, transform it to the appropriate class and test whether your transformation worked.

```

```{block, opts.label = "clues"}
You can use the `class()` function to check the class of an object in `R`. To change a class, for example from character to numeric, you can use the family of "as"-functions, for example `as.numeric()`

```
```{r, solution = TRUE}
# Checking variable class
class(Selection$likeCount)

# Transforming class
Selection$likeCount <- as.numeric(Selection$likeCount)

# Rechecking class
class(Selection$likeCount)
summary(Selection$likeCount)

```
```{block, box.title = "Exercise 5", box.body = list(fill = "white"), box.icon = "fa-star"}
Check the `textOriginal` column in your Selection dataframe. There are still hyperlinks in the column that we should remove for later text analysis steps. Extract the hyperlinks from the `textOriginal` column into a new list called `Links`. In addition, create a new variable called `LinksDel` that contains the `textOriginal` but _without_ the hyperlinks.


```

```{block, opts.label = "clues"}
The `qdapRegex` package has many pre-built functions for detecting, removing, and replacing specific character strings. You can, for example, use the `rm_url()` function to extract and replace hyperlinks. As a reminder: You can check the documentation for this function with `?rm_url()`.

```
```{r, solution = TRUE}
# Loading package
library(qdapRegex)

# Checking column
Selection$textOriginal[276:286]

# extracting hyperlinks
Links <- rm_url(Selection$textOriginal, extract = TRUE)
Links[276:286]

# removing hyperlinks
LinksDel <- rm_url(Selection$textOriginal)
LinksDel[276:286]

```

```{block, box.title = "Exercise 6", box.body = list(fill = "white"), box.icon = "fa-star"}
Check the `LinksDel` variable to see if there are still emoji contained in the column. For our later analysis, we want to do three things:

1) Create one column without hyperlinks and emojis for easier text mining
2) Create one column where emojis are replaced by a textual description for easier text mining
3) Create one column containing only the textual description of emojis

To achieve this, we first need a dictionary of emojis and their corresponding textual descriptions in a usable format.
Load the `emo` package and have a look at the contained dataframe `jis`. Assign it to a new object called `EmojiList`. Afterwards, source the provided `CamelCase.R` script (in the `scripts` folder) to transform the textual description from regular case into CamelCase. Finally, create a new variable called `TextEmoDel` containing the text without the emoji (hint: you can use the `ji_replace_all()` function from the `emo` package for that).

```

```{block, opts.label = "clues"}
We provide you with a function that capitalizes the first character of each word. The function is called `simpleCap()` and the name of the script is `CamelCase.R`. You can load it into your workspace using the `source()` function and specifying it's location. You can find the function in the `scripts` folder. Keep in mind that this function only capitalizes the first letters of each word, so you still need to get rid of the extra space characters. The `gsub()` function is a handy tool for this purpose. You can use the `ji_replace_all()` function from the emo package to replace Emoji with an empty string ("").

```
```{r, solution = TRUE}
# loading package
library(emo)

# sourcing script
source("../scripts/CamelCase.R")

# Reassigning dataframe
EmojiList <- jis

# Applying the function to all the names
CamelCaseEmojis <- lapply(jis$name, simpleCap)

# Deleting the empty spaces
CollapsedEmojis <- lapply(CamelCaseEmojis,function(x){gsub(" ", "", x, fixed = TRUE)})

# Formatting back from a list to a vector
EmojiList[,4] <- unlist(CollapsedEmojis)

# Overview of first 10 rows
EmojiList[1:10,c(1,3,4)]

# Creating text column with removed Emoji (and hyperlinks)
TextEmoDel <- ji_replace_all(LinksDel,"")

# Checking
LinksDel[c(459,469,694)]
TextEmoDel[c(459,469,694)]

```

```{block, box.title = "Exercise 7", box.body = list(fill = "white"), box.icon = "fa-star"}
Ultimately, we want to use our `EmojiList` dataframe to replace the instances of emojis in our text with the textual descriptions. We can do that by looping through all emoji in all texts and replacing them one at a time. There is a problem however: Some emojis are made up of multiple "shorter" emojis. If we match part of a "longer" emoji and replace it with its textual description, the rest will become unreadable. For this reason, we need to make sure that we replace the emoji **from longest to shortest**. Sort the `EmojiList` dataframe by the length of the `emoji` column from longest to shortest.

```

```{block, opts.label = "clues"}
You can count the number of characters in a vector of text using the `nchar()` function. You can reorder dataframes using the `order` function and you can reverse an order using the `rev()` function.

```
```{r, solution = TRUE}
# ordering from longest to shortest
EmojiList <- EmojiList[rev(order(nchar(jis$emoji))),]

# Overview of new order
head(EmojiList[,c(1,3,4)],5)

```


```{block, box.title = "Exercise 8", box.body = list(fill = "white"), box.icon = "fa-star"}
We now have a working dictionary for replacing emojis with a textual description! Create a new variable called `TextEmoRep` as a copy of the `LinksDel` variable. Next, loop through the ordered `EmojiList` and, for every element in `TextEmoRep`, replace the contained emoji with "EMOJI_" followed by their textual description. You can use the `rm_default()` function from the `qdapRegex` package to replace custom patterns. Be sure to check the documentation so you can set the appropriate options for the function.

*NB*: There will be warnings in your console even if you are doing everything right.

```

```{block, opts.label = "clues"}
Loop through the dictionary sorted from longest to shortest emoji. You need to use a `for` loop to go through all emojis for all comments, one at a time. The `paste()` function is useful for adding the prefix "EMOJI_" in front of your textual descriptions. Don't forget to set the arguments `fixed = TRUE`, `clean = TRUE` and `trim = FALSE` in your call to `rm_default()`  

```
```{r, solution = TRUE, warning=FALSE,message=FALSE}

# Assigning the column to a new variable
TextEmoRep <- LinksDel

# switching off warnings
options(warn=-1)

# Looping through all Emojis for all comments
for (i in 1:dim(EmojiList)[1]) {

  TextEmoRep <- rm_default(TextEmoRep,
                    pattern = EmojiList[i,3],
                    replacement = paste0("EMOJI_",
                                       EmojiList[i,4],
                                       " "),
                    fixed = TRUE,
                    clean = FALSE,
                    trim = FALSE)
}

# checking results
LinksDel[c(459,469,694)]
TextEmoRep[c(459,469,694)]

```

```{block, box.title = "Exercise 9", box.body = list(fill = "white"), box.icon = "fa-star"}
We now have the original text column, and the text column with removed hyperlinks in which emojis are replaced with their textual descriptions (`TextEmoRep`). We need one more variable that _only_ contains the textual descriptions of the emojis. You can use our predefined function `ExtractEmoji()` from the `scripts` folder to create this variable.

```

```{block, opts.label = "clues"}
Use the `source()` function to source the `ExtractEmoji.R` script from the `scripts` folder and then `sapply()` the `ExtractEmoji()` function to the variable `TextEmoRep`. To remove useless rownames from the extracted Emojis, you can set `names(Emoji)` to `NULL`

```
```{r, solution = TRUE}
# sourcing function
source("../scripts/ExtractEmoji.R")

# Using function
Emoji <- sapply(TextEmoRep,ExtractEmoji)
names(Emoji) <- NULL

# checking results
LinksDel[c(459,469,694)]
TextEmoRep[c(459,469,694)]
Emoji[c(459,469,694)]

```

```{block, box.title = "Exercise 10", box.body = list(fill = "white"), box.icon = "fa-star"}
We now have selected all the variables we need, brought them into the right formats, cleaned the text, and extracted some additional information from it. As a final step, create a new dataframe called `df` that contains the following variables:

- Selection$authorDisplayName

- Selection$textOriginal

- TextEmoRep

- TextEmoDel

- Emoji

- Selection$likeCount

- Links

- Selection$publishedAt

- Selection$updatedAt

- Selection$parentId

- Selection$id

Set the following names for the column in the new dataframe:

- Author

- Text

- TextEmojiReplaced

- TextEmojiDeleted

- Emoji

- LikeCount

- URL

- Published

- Updated

- ParentId

- CommentID

Save the new dataframe as an RDS object with the name "ParsedComments.Rds"

```

```{block, opts.label = "clues"}
You can use the `cbind.data.frame()` function to paste together multiple columns into a dataframe. You need to set the argument `stringsAsFactors = FALSE` though (if your `R` version is < 4.0.0), to prevent strings from being interpreted as factor variables. In addition, the variables `Links` and `Emoji` are lists and can contain multiple values per row. For this reason, you need to enclose them with the `I()` function to be able to put them into a dataframe. You can save your result using the `saveRDS()` function.


```
```{r, solution = TRUE}
# creating df dataframe (use I() function to enclose Emoji and Links)
df <- cbind.data.frame(Selection$authorDisplayName,
                       Selection$textOriginal,
                       TextEmoRep,
                       TextEmoDel,
                       I(Emoji),
                       Selection$likeCount,
                       I(Links),
                       Selection$publishedAt,
                       Selection$updatedAt,
                       Selection$parentId,
                       Selection$id,
                       stringsAsFactors = FALSE)

# setting column names
names(df) <- c("Author",
               "Text",
               "TextEmojiReplaced",
               "TextEmojiDeleted",
               "Emoji",
               "LikeCount",
               "URL",
               "Published",
               "Updated",
               "ParentId",
               "CommentID")

# deleting row names
row.names(df) <- NULL

# saving dataframe
saveRDS(df, file = "../data/ParsedComments.rds")

```

